

# ==运算规则



1.两端类型相同,比较值
2.两端存在 NaN,返回false
3.undefined 和 null 只有与自身比较，或者互相比较时,才会返回true
4.两端都是原始类型,转换成数字比较
5 一端是原始类型，一端是对象类型,把对象转换成原始类型后进入第4步

## 对象如何转原始类型?

#### 1.如果对象拥有[Symbol.toPrimitive]方法,

调用该方法若该方法能得到原始值,使用该原始值;

若得不到原始值,抛出异常

#### 2调用对象的valueof方法

若该方法能得到原始值,使用该原始值:

若得不到原始值,进入下一步

#### 3.调用对象的tostring方法

若该方法能得到原始值,使用该原始值;

若得不到原始值,抛出异常





## 隐式转换

字符串与数字的隐式转换：

当使用加号运算符（+）将字符串与数字相加时，数字会被转换为字符串并进行字符串拼接。
当使用其他算术运算符（如减号、乘号）或比较运算符（如小于、大于）时，字符串会被转换为数字。
数字与布尔值的隐式转换：

当使用布尔值与数字进行算术运算时，布尔值会被转换为数字（true转换为1，false转换为0）。
当使用布尔值与数字进行比较运算时，数字会被转换为布尔值（0被视为false，非零数字被视为true）。
对象与原始值的隐式转换：

当对象用作字符串上下文（如在字符串拼接中）时，对象会被转换为字符串，通常调用对象的toString()方法。
当对象用作算术上下文（如在算术运算中）时，对象会被转换为数字，通常调用对象的valueOf()方法。
值与布尔值的隐式转换：

在条件语句中，JavaScript将非布尔值转换为布尔值。以下值被视为false：false、0、空字符串、null、undefined和NaN。其他所有值都被视为true。





## 相加

``` 
20 + true + null + undefined + 'string' + [] + {a:1}
1 20 + true -> 20 + 0 -> 20
2 20 + null -> 20 + 0 -> 20
3 20 + undefined -> NaN (undefined 转不了数字)
4 NaN + 'string' -> 'NaNstring'
5 'NaNstring' + [] -> 'NaNstring' + '' -> 'NaNstring'
6 'NaNstring' + {a:1} -> 'NaNstring' + '[object Object]' -> 'NaNstring[object Object]'
```



```javascript
[] + []
[] + ![]
[] == ![]
[] == []

1. 结果是 ''，空字符串，因为数组是对象类型，先转为字符串在进行加法运算
2. 结果是 'false'，因为这个表达式等同于[] + false，对象转为字符串即'' + false
3. 结果是true，这个相对复杂，首先这个表达式等同于[] == false，
  然后布尔转为数字：[] == 0，
    然后对象要转为字符串再比较，即：'' == 0，这样是一个字符串和一个数值比较，
      要先将字符串转为数字，即：0 == 0
4. 是false，因为不是同一个对象的引用


null == 0
null > 0
null < 0
null >= 0
null <= 0

null == 0是false，因为null只和自己或者undefined相等，其他都是false

null和0进行大小比较时候，因为0是数值类型，因此将null也转为数值进行比较，所以

null > 0和null < 0为false，而null >= 0和null <= 0为true。
```

```javascript
1 == {}
个人推测
1 == ''
1 == 0
false
```

###  == 判断

类型比较

![](https://raw.githubusercontent.com/xxxsjan/pic-bed/main/202305151235728.jpeg)